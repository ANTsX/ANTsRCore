% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/antsRegistration.R
\name{antsRegistration}
\alias{antsRegistration}
\title{Perform registration between two images.}
\usage{
antsRegistration(
  fixed = NULL,
  moving = NULL,
  typeofTransform = "SyN",
  initialTransform = NA,
  outprefix = NULL,
  mask = NULL,
  gradStep = 0.2,
  flowSigma = 3,
  totalSigma = 0,
  affMetric = "mattes",
  affSampling = 32,
  synMetric = "mattes",
  synSampling = 32,
  affIterations,
  regIterations = c(40, 20, 0),
  multivariateExtras,
  restrictTransformation,
  writeCompositeTransform = FALSE,
  randomSeed,
  verbose = FALSE,
  printArgs = FALSE,
  ...
)
}
\arguments{
\item{fixed}{fixed image to which we register the moving image.}

\item{moving}{moving image to be mapped to fixed space.}

\item{typeofTransform}{A linear or non-linear registration type.  Mutual
information metric by default. See \code{Details.}}

\item{initialTransform}{transforms to prepend}

\item{outprefix}{output will be named with this prefix.}

\item{mask}{mask the registration.  can be a single mask or pair of the form \code{list(maskFixed,maskMoving)}}

\item{gradStep}{gradient step size (not for all tx)}

\item{flowSigma}{smoothing for update field}

\item{totalSigma}{smoothing for total field}

\item{affMetric}{the metric for the affine part (GC, mattes, meansquares)}

\item{affSampling}{the sampling parameter for the affine metric}

\item{synMetric}{the metric for the syn part (CC, mattes, meansquares, demons)}

\item{synSampling}{the nbins or radius parameter for the syn metric}

\item{affIterations}{vector of iterations for low-dimensional registration.
we will set the smoothing and multi-resolution parameters based on the
length of this vector.}

\item{regIterations}{vector of iterations for syn.  we will set the smoothing
and multi-resolution parameters based on the length of this vector.}

\item{multivariateExtras}{list of additional images and metrics which will
trigger the use of multiple metrics in the registration process
in the deformable stage. Multivariate metrics needs 5 entries:
name of metric, fixed, moving, weight, samplingParam.
the list should be of the form
\code{ list( list( "nameOfMetric2", img, img, weight, metricParam ) ) }.
Another example would be \code{ list( list( "MeanSquares", f2, m2, 0.5, 0 ),
list( "CC", f2, m2, 0.5, 2 ) ) }.  This is only compatible with the
\code{SyNOnly} or \code{ElasticOnly} transformation.}

\item{restrictTransformation}{This option allows the user to restrict the
optimization of the displacement field, translation, rigid or affine
transform on a per-component basis. For example, if one wants to limit
the deformation or rotation of 3-D volume to the first two dimensions,
this is possible by specifying a weight vector of \code{c(1,1,0)} for a
3D deformation field or \code{c(1,1,0,1,1,0)} for a rigid transformation.
Restriction currently only works if there are no preceding transformations.}

\item{writeCompositeTransform}{if \code{TRUE}, will write transformations to h5 format.  Defaults to FALSE.}

\item{randomSeed}{integer random seed. combine with setting
ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS environment variable to limit the
impact of numerical differences.}

\item{verbose}{request verbose output (useful for debugging)}

\item{printArgs}{print raw command line (useful for debugging)}

\item{...}{additional options see antsRegistration in ANTs}
}
\value{
outputs a list containing:
\itemize{
  \item{warpedmovout: }{Moving image warped to space of fixed image.}
  \item{warpedfixout: }{Fixed image warped to space of moving image.}
  \item{fwdtransforms: }{Transforms to move from moving to fixed image.}
  \item{invtransforms: }{Transforms to move from fixed to moving image.}
}
Ouptut of 1 indicates failure
}
\description{
Register a pair of images either through the full or simplified interface
to the ANTs registration method.
}
\details{

}
\examples{

#print help
antsRegistration()
fi <- antsImageRead(getANTsRData("r16") )
mi <- antsImageRead(getANTsRData("r64") )
mytx2 <- antsRegistration(fixed=fi,  typeofTransform = '')
rig <- antsRegistration(fixed=fi, moving = mi,
 typeofTransform = 'Rigid', verbose = TRUE)
trans = readAntsrTransform(rig$fwdtransforms, 2)
postrig <- antsRegistration(fixed=fi, moving=mi,
typeofTransform = "Affine", initialTransform = trans)
for (itype in c("AffineFast", "BOLDAffine")) {
print(itype)
mytx2 <- antsRegistration(fixed=fi, moving=mi,
typeofTransform = itype)
}
mytx2 <- antsRegistration(fixed=fi, moving=mi,
typeofTransform = "SyNOnly",
multivariateExtras = list(list( "MeanSquares", fi, mi, 0.5, 0 )) )
testthat::expect_error(
antsRegistration(fixed=fi, moving=mi, typeofTransform = "sdf")
)
bad <- antsRegistration(fixed=fi, moving=mi, regIterations = 40)
affIterations = c(3, 2, 1, 0)
mytx2 <- antsRegistration(fixed=fi, moving=mi,
affIterations = affIterations)
# set below for slower but numerically repeatable results
# these should be set in .Renviron not by sys calls
#  Sys.setenv(ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS = 1)
#  Sys.setenv(ANTS_RANDOM_SEED = 20180716)
fi <- antsImageRead(getANTsRData("r16") )
mi <- antsImageRead(getANTsRData("r64") )
fi<-resampleImage(fi,c(60,60),1,0)
mi<-resampleImage(mi,c(50, 50),1,0) # speed up
mytx <- antsRegistration(fixed=fi, moving=mi, typeofTransform = c('SyN') )
mywarpedimage <- antsApplyTransforms( fixed=fi, moving=mi,
  transformlist=mytx$fwdtransforms )
mytx2 <- antsRegistration(fixed=fi, moving=mi, typeofTransform = c('SyN') )
mywarpedimage2 <- antsApplyTransforms( fixed=fi, moving=mi,
  transformlist=mytx2$fwdtransforms )
# testthat::expect_equal(as.array(mywarpedimage), as.array(mywarpedimage2))

\dontrun{ # quick visualization fix for images with odd orientation
mni = antsImageRead( getANTsRData( "mni" ) )
strokt1=antsImageRead('strokt1.nii.gz')
strokt1reg=antsRegistration(
  fixed=mni,
  moving=strokt1,
  typeofTransform = "QuickRigid",verbose=TRUE )
 plot(  strokt1reg$warpedmovout, axis=3, nslices=20)
# now - how to use a mask
fi <- antsImageRead(getANTsRData("r16") )
fiseg = kmeansSegmentation( fi, 3 )
mi <- antsImageRead(getANTsRData("r64") )
msk = thresholdImage(fiseg$segmentation, 0, 0 )
mytx <- antsRegistration(fixed=fi, moving=mi, typeofTransform = c('SyNCC'),
  mask=msk, verbose=F )
jac = createJacobianDeterminantImage( fi, mytx$fwdtransforms[1] )
}

}
\author{
Shrinidhi KL, Tustison NJ, Avants BB
}
