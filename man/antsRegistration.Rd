% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/antsRegistration.R
\name{antsRegistration}
\alias{antsRegistration}
\title{Perform registration between two images.}
\usage{
antsRegistration(fixed = NA, moving = NA, typeofTransform = "SyN",
  initialTransform = NA, outprefix = NULL, mask = NA,
  gradStep = 0.2, flowSigma = 3, totalSigma = 0,
  affMetric = "mattes", affSampling = 32, synMetric = "mattes",
  synSampling = 32, affIterations, regIterations = c(40, 20, 0),
  multivariateExtras, restrictTransformation, verbose = FALSE, ...)
}
\arguments{
\item{fixed}{fixed image to which we register the moving image.}

\item{moving}{moving image to be mapped to fixed space.}

\item{typeofTransform}{A linear or non-linear registration type.  Mutual
information metric by default. See \code{Details.}}

\item{initialTransform}{transforms to prepend}

\item{outprefix}{output will be named with this prefix.}

\item{mask}{mask the registration.  can be a single mask or pair of the form \code{list(maskFixed,maskMoving)}}

\item{gradStep}{gradient step size (not for all tx)}

\item{flowSigma}{smoothing for update field}

\item{totalSigma}{smoothing for total field}

\item{affMetric}{the metric for the affine part (GC, mattes, meansquares)}

\item{affSampling}{the nbins or radius parameter for the syn metric}

\item{synMetric}{the metric for the syn part (CC, mattes, meansquares, demons)}

\item{synSampling}{the nbins or radius parameter for the syn metric}

\item{affIterations}{vector of iterations for low-dimensional registration.
we will set the smoothing and multi-resolution parameters based on the
length of this vector.}

\item{regIterations}{vector of iterations for syn.  we will set the smoothing
and multi-resolution parameters based on the length of this vector.}

\item{multivariateExtras}{list of additional images and metrics which will
trigger the use of multiple metrics in the registration process
in the deformable stage. Multivariate metrics needs 5 entries:
name of metric, fixed, moving, weight, samplingParam.
the list should be of the form
\code{ list( list( "nameOfMetric2", img, img, weight, metricParam ) ) }.
Another example would be \code{ list( list( "MeanSquares", f2, m2, 0.5, 0 ),
list( "CC", f2, m2, 0.5, 2 ) ) }.  This is only compatible with the
\code{SyNOnly} transformation.}

\item{restrictTransformation}{This option allows the user to restrict the
optimization of the displacement field, translation, rigid or affine
transform on a per-component basis. For example, if one wants to limit
the deformation or rotation of 3-D volume to the first two dimensions,
this is possible by specifying a weight vector of \code{c(1,1,0)} for a
3D deformation field or \code{c(1,1,0,1,1,0)} for a rigid transformation.
Restriction currently only works if there are no preceding transformations.}

\item{verbose}{request verbose output (useful for debugging)}

\item{...}{additional options see antsRegistration in ANTs}
}
\value{
outputs a list containing:
\itemize{
  \item{warpedmovout: }{Moving image warped to space of fixed image.}
  \item{warpedfixout: }{Fixed image warped to space of moving image.}
  \item{fwdtransforms: }{Transforms to move from moving to fixed image.}
  \item{invtransforms: }{Transforms to move from fixed to moving image.}
}
Ouptut of 1 indicates failure
}
\description{
Register a pair of images either through the full or simplified interface
to the ANTs registration method.
}
\details{
typeofTransform can be one of:
\itemize{
  \item{"Translation": }{Translation transformation.}
  \item{"Rigid": }{Rigid transformation: Only rotation and translation.}
  \item{"Similarity": }{Similarity transformation: scaling, rotation and
  translation.}
  \item{"QuickRigid": }{Rigid transformation: Only rotation and translation.
  May be useful for quick visualization fixes.'}
  \item{"DenseRigid": }{Rigid transformation: Only rotation and translation.
  Employs dense sampling during metric estimation.'}
  \item{"BOLDRigid": }{Rigid transformation: Parameters typical for BOLD
  to BOLD intrasubject registration'.'}
  \item{"Affine": }{Affine transformation: Rigid + scaling.}
  \item{"AffineFast": }{Fast version of \code{Affine}.}
  \item{"BOLDAffine": }{Affine transformation: Parameters typical for BOLD
  to BOLD intrasubject registration'.'}
  \item{"TRSAA": }{translation, rigid, similarity, affine (twice). please set
    \code{regIterations} if using this option.  this would be used in cases
    where you want a really high quality affine mapping (perhaps with mask).}
  \item{"ElasticSyN": }{Symmetric normalization: Affine + deformable transformation.
    Uses \code{synMetric} as optimization metric and elastic regularization.}
  \item{"SyN": }{Symmetric normalization: Affine + deformable transformation.
    Uses \code{synMetric} as optimization metric.}
  \item{"SyNRA": }{Symmetric normalization: Rigid + Affine + deformable transformation.
    Uses \code{synMetric} as optimization metric.}
  \item{"SyNOnly": }{Symmetric normalization: no initial transformation.
    Uses \code{synMetric} as optimization metric.  Assumes images are
    aligned by an inital transformation. Can be useful if you want to run
    an unmasked affine followed by masked deformable registration.}
  \item{"SyNCC": }{SyN, but with cross-correlation as the metric.
    Note, the default or chosen parameters will be replaced with
    \code{synMetric="CC", synSampling=4, synits="2100x1200x1200x20",
         smoothingsigmas="3x2x1x0", shrinkfactors="4x3x2x1"}. }
  \item{"SyNabp": }{SyN optimized for abpBrainExtraction, forces mutual information
    as optimization metric.}
  \item{"SyNBold": }{SyN, but optimized for registrations between
    BOLD and T1 images.}
  \item{"SyNBoldAff": }{SyN, but optimized for registrations between
    BOLD and T1 images, with additional affine step.}
  \item{"SyNAggro": }{SyN, but with more aggressive registration
    (fine-scale matching and more deformation).  Takes more time than \code{SyN}.}
  \item{"TVMSQ": }{time-varying diffeomorphism with mean square metric}
  \item{"TVMSQC": }{time-varying diffeomorphism with mean square metric
  for very large deformation}
}
}
\examples{

#print help
antsRegistration()
fi <- antsImageRead(getANTsRData("r16") )
mi <- antsImageRead(getANTsRData("r64") )
mytx2 <- antsRegistration(fixed=fi,  typeofTransform = '')
rig <- antsRegistration(fixed=fi, moving = mi,
 typeofTransform = 'Rigid', verbose = TRUE)
trans = readAntsrTransform(rig$fwdtransforms, 2)
postrig <- antsRegistration(fixed=fi, moving=mi,
typeofTransform = "Affine", initialTransform = trans)
for (itype in c("AffineFast", "BOLDAffine")) {
print(itype)
mytx2 <- antsRegistration(fixed=fi, moving=mi,
typeofTransform = itype)
}
mytx2 <- antsRegistration(fixed=fi, moving=mi,
typeofTransform = "SyNOnly",
multivariateExtras = list(list( "MeanSquares", fi, mi, 0.5, 0 )) )
testthat::expect_error(
antsRegistration(fixed=fi, moving=mi, typeofTransform = "sdf")
)
bad <- antsRegistration(fixed=fi, moving=mi, regIterations = 40)
affIterations = c(3, 2, 1, 0)
mytx2 <- antsRegistration(fixed=fi, moving=mi,
affIterations = affIterations)
# set below for slower but numerically repeatable results
# these should be set in .Renviron not by sys calls
#  Sys.setenv(ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS = 1)
#  Sys.setenv(ANTS_RANDOM_SEED = 20180716)
fi <- antsImageRead(getANTsRData("r16") )
mi <- antsImageRead(getANTsRData("r64") )
fi<-resampleImage(fi,c(60,60),1,0)
mi<-resampleImage(mi,c(50, 50),1,0) # speed up
mytx <- antsRegistration(fixed=fi, moving=mi, typeofTransform = c('SyN') )
mywarpedimage <- antsApplyTransforms( fixed=fi, moving=mi,
  transformlist=mytx$fwdtransforms )
mytx2 <- antsRegistration(fixed=fi, moving=mi, typeofTransform = c('SyN') )
mywarpedimage2 <- antsApplyTransforms( fixed=fi, moving=mi,
  transformlist=mytx2$fwdtransforms )
# testthat::expect_equal(as.array(mywarpedimage), as.array(mywarpedimage2))

\dontrun{ # quick visualization fix for images with odd orientation
mni = antsImageRead( getANTsRData( "mni" ) )
strokt1=antsImageRead('strokt1.nii.gz')
strokt1reg=antsRegistration(
  fixed=mni,
  moving=strokt1,
  typeofTransform = "QuickRigid",verbose=TRUE )
 plot(  strokt1reg$warpedmovout, axis=3, nslices=20)
# now - how to use a mask
fi <- antsImageRead(getANTsRData("r16") )
fiseg = kmeansSegmentation( fi, 3 )
mi <- antsImageRead(getANTsRData("r64") )
msk = thresholdImage(fiseg$segmentation, 0, 0 )
mytx <- antsRegistration(fixed=fi, moving=mi, typeofTransform = c('SyNCC'),
  mask=msk, verbose=F )
jac = createJacobianDeterminantImage( fi, mytx$fwdtransforms[1] )
}

}
\author{
Shrinidhi KL, Tustison NJ, Avants BB
}
